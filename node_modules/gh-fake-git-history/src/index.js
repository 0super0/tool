const util = require("util");
const os = require("os");
const { exec } = require("child_process");
const fs = require("fs");
const execAsync = util.promisify(exec);
const {
  parse,
  addDays,
  addYears,
  isWeekend,
  setHours,
  setMinutes
} = require("date-fns");
const chalk = require("chalk");
const ora = require("ora");
const boxen = require("boxen");

let firstCommit = true;

async function sleep(millis) {
  return new Promise(resolve => setTimeout(resolve, millis));
}

function getRandomIntInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

module.exports = function(props) {
  const filename = "foo.txt";
  const pushBranches = props.pushBranches;
  const commitDateList = generateCommitDateList({
    workdaysOnly: props.workdaysOnly,
    commitsPerDay: props.commitsPerDay.split(","),
    startDate: props.startDate
      ? parse(props.startDate)
      : addYears(new Date(), -1),
    endDate: props.endDate ? parse(props.endDate) : new Date()
  });

  (async function generateHistory() {
    const spinner = ora("Generating your GitHub activity\n").start();

    const command = commitDateList
      .map(date => {
        return doCommits(date, filename, pushBranches);
      })
      .join(";");

    await execAsync(command);

    if (pushBranches) {
      commitDateList.forEach(date => {
        pushCommitsToBranches(date);
      });
    }

    spinner.succeed();

    console.log(
      boxen(
        `${chalk.green("Success!")} ${
          commitDateList.length
        } commits have been created.`,
        { borderColor: "yellow", padding: 1, align: "center" }
      )
    );
  })();

  /**
   * Executes a shell command and return it as a Promise.
   * @param cmd {string}
   * @return {Promise<string>}
   */
  function execShellCommand(cmd) {
    const exec = require("child_process").exec;
    return new Promise((resolve, reject) => {
      exec(cmd, (error, stdout, stderr) => {
        if (error) {
          console.warn(error);
        }
        resolve(stdout ? stdout : stderr);
      });
    });
  }

  function generateCommitDateList({
    commitsPerDay,
    workdaysOnly,
    startDate,
    endDate
  }) {
    const commitDateList = [];
    let currentDate = startDate;

    while (currentDate <= endDate) {
      if (workdaysOnly && isWeekend(currentDate)) {
        currentDate = addDays(currentDate, 1);
        continue;
      }
      for (let i = 0; i < getRandomIntInclusive(...commitsPerDay); i++) {
        const dateWithHours = setHours(
          currentDate,
          getRandomIntInclusive(9, 16)
        );
        const commitDate = setMinutes(
          dateWithHours,
          getRandomIntInclusive(0, 59)
        );
        commitDateList.push(commitDate);
      }
      currentDate = addDays(currentDate, 1);
    }

    return commitDateList;
  }
};

function randomLOCNum() {
  return Math.floor(Math.random() * Math.floor(5));
}

function addLines(date, filename, pushBranches) {
  let branch = branchNameFromDate(date);
  let loc = randomLOCNum();
  console.log(`Adding ${loc} lines...`);
  if (pushBranches) {
    return `for i in {1..${loc}}; do echo "${date}" >> ${filename}; done; git co -b ${branch}; git add .; git commit --date "${date}" -m "added ${loc} lines"`;
  }
  return `for i in {1..${loc}}; do echo "${date}" >> ${filename}; done; git add .; git commit --date "${date}" -m "added ${loc} lines"`;
}

function removeLines(date, filename, pushBranches) {
  let branch = branchNameFromDate(date);
  let loc = randomLOCNum();

  console.log(`Removing ${loc} lines...`);

  let data = readFile(filename);
  for (line = 0; line < loc; line++) {
    data.splice(line, 1);
  }
  writeFile(data, filename);
  if (pushBranches) {
    return `echo "finished removing lines" >> ${filename}; git co -b ${branch}; git add .; git commit --date "${date}" -m "removed ${loc} lines"`;
  }
  return `echo "finished removing lines" >> ${filename}; git add .; git commit --date "${date}" -m "removed ${loc} lines"`;
}

function modifyLines(date, filename, pushBranches) {
  let branch = branchNameFromDate(date);
  let loc = randomLOCNum();

  console.log(`Modifying ${loc} lines...`);

  let data = readFile(filename);
  for (line = 0; line < loc; line++) {
    data[line] = "modified-line";
  }
  writeFile(data, filename);
  if (pushBranches) {
    return `echo "finished modifying lines" >> ${filename}; git co -b ${branch}; git add .; git commit --date "${date}" -m "modified ${loc} lines"`;
  }
  return `echo "finished modifying lines" >> ${filename}; git add .; git commit --date "${date}" -m "modified ${loc} lines"`;
}

function randomCommitActivity() {
  const commitActions = [addLines, removeLines, modifyLines];
  return commitActions[Math.floor(Math.random() * commitActions.length)];
}

function branchNameFromDate(date) {
  return date
    .toString()
    .split(" ")
    .slice(0, 3)
    .join("-");
}

function pushCommitsToBranches(date) {
  let branch = branchNameFromDate(date);
  console.log(`Pushing commits to branch: ${branch}`);
  exec(`git co ${branch}; git push origin ${branch}`);
}

function readFile(filename) {
  return fs
    .readFileSync(filename)
    .toString()
    .split("\n");
}

function writeFile(data, filename) {
  let text = data.join("\n");
  fs.writeFile(filename, text, function(err) {
    if (err) {
      console.log(err);
      throw err;
    }
  });
}

function doCommits(date, filename, pushBranches) {
  if (firstCommit) {
    firstCommit = false;
    return addLines(date, filename, pushBranches);
  } else {
    return randomCommitActivity()(date, filename, pushBranches);
  }
}
